diff --git a/Makefile.am b/Makefile.am
index 67a0190..f06ee0c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -10,7 +10,7 @@ man_MANS = mount.cifs.8
 
 if CONFIG_CIFSUPCALL
 sbin_PROGRAMS = cifs.upcall
-cifs_upcall_SOURCES = cifs.upcall.c data_blob.c asn1.c spnego.c util.c
+cifs_upcall_SOURCES = cifs.upcall.c data_blob.c asn1.c spnego.c
 cifs_upcall_LDADD = -ltalloc -lkeyutils $(KRB5_LDADD)
 man_MANS += cifs.upcall.8
 
diff --git a/cifs.upcall.c b/cifs.upcall.c
index 479517c..04d8898 100644
--- a/cifs.upcall.c
+++ b/cifs.upcall.c
@@ -45,8 +45,8 @@
 #include <time.h>
 #include <netdb.h>
 #include <arpa/inet.h>
+#include <ctype.h>
 
-#include "util.h"
 #include "replace.h"
 #include "data_blob.h"
 #include "spnego.h"
@@ -747,6 +747,16 @@ static int ip_to_fqdn(const char *addrstr, char *host, size_t hostlen)
 	return 0;
 }
 
+/* walk a string and lowercase it in-place */
+static void
+lowercase_string(char *c)
+{
+	while(*c) {
+		*c = tolower(*c);
+		++c;
+	}
+}
+
 static void usage(void)
 {
 	syslog(LOG_INFO, "Usage: %s [-t] [-v] [-l] key_serial", prog);
@@ -770,8 +780,9 @@ int main(const int argc, char *const argv[])
 	unsigned int have;
 	long rc = 1;
 	int c, try_dns = 0, legacy_uid = 0;
-	char *buf, *princ = NULL, *ccname = NULL;
+	char *buf, *ccname = NULL;
 	char hostbuf[NI_MAXHOST], *host;
+	char princ[NI_MAXHOST + 5]; /* 5 == len of "cifs/" */
 	struct decoded_args arg;
 	const char *oid;
 	uid_t uid;
@@ -849,6 +860,13 @@ int main(const int argc, char *const argv[])
 		goto out;
 	}
 
+	if (strlen(arg.hostname) >= NI_MAXHOST) {
+		syslog(LOG_ERR, "hostname provided by kernel is too long");
+		rc = 1;
+		goto out;
+
+	}
+
 	if (!legacy_uid && (have & DKD_HAVE_CREDUID))
 		uid = arg.creduid;
 	else if (have & DKD_HAVE_UID)
@@ -877,35 +895,82 @@ int main(const int argc, char *const argv[])
 	switch (arg.sec) {
 	case MS_KRB5:
 	case KRB5:
-retry_new_hostname:
-		/* for "cifs/" service name + terminating 0 */
-		datalen = strlen(host) + 5 + 1;
-		princ = calloc(sizeof(char), datalen);
-		if (!princ) {
-			rc = -ENOMEM;
-			break;
-		}
-
+		/*
+		 * Andrew Bartlett's suggested scheme for picking a principal
+		 * name, based on a supplied hostname.
+		 *
+		 * INPUT: fooo
+		 * TRY in order:
+		 * cifs/fooo@REALM
+		 * cifs/fooo.<guessed domain ?>@REALM
+		 *
+		 * INPUT: bar.example.com
+		 * TRY only:
+		 * cifs/bar.example.com@REALM
+		 */
 		if (arg.sec == MS_KRB5)
 			oid = OID_KERBEROS5_OLD;
 		else
 			oid = OID_KERBEROS5;
 
-		/*
-		 * try getting a cifs/ principal first and then fall back to
-		 * getting a host/ principal if that doesn't work.
-		 */
-		strlcpy(princ, "cifs/", datalen);
-		strlcpy(princ + 5, host, datalen - 5);
-		rc = handle_krb5_mech(oid, princ, &secblob, &sess_key, ccname);
-		if (!rc)
-			break;
+retry_new_hostname:
+		lowercase_string(host);
+		/* try "cifs/hostname" first */
+		rc = snprintf(princ, sizeof(princ), "cifs/%s", host);
+		if (rc < 0 || (size_t)rc >= sizeof(princ)) {
+			syslog(LOG_ERR,"Unable to set hostname %s in buffer.", host);
+			goto out;
+		}
 
-		memcpy(princ, "host/", 5);
 		rc = handle_krb5_mech(oid, princ, &secblob, &sess_key, ccname);
 		if (!rc)
 			break;
 
+		/*
+		 * If hostname has a '.', assume it's a FQDN, otherwise we want to
+		 * guess the domainname.
+		 */
+		if (!strchr(host, '.')) {
+			struct addrinfo hints;
+			struct addrinfo *ai;
+			char *domainname;
+
+			/*
+			 * use getaddrinfo() to resolve the hostname of the server
+			 * and set ai_canonname.
+			 */
+			memset(&hints, 0, sizeof(hints));
+			hints.ai_family = AF_UNSPEC;
+			hints.ai_flags = AI_CANONNAME;
+			rc = getaddrinfo(host, NULL, &hints, &ai);
+			if (rc) {
+				syslog(LOG_ERR, "Unable to resolve host address: %s [%s]",
+				       host, gai_strerror(rc));
+				break;
+			}
+
+			/* scan forward to first '.' in ai_canonnname */
+			domainname = strchr(ai->ai_canonname, '.');
+			if (!domainname) {
+				rc = -EINVAL;
+				freeaddrinfo(ai);
+				break;
+			}
+			lowercase_string(domainname);
+			rc = snprintf(princ, sizeof(princ), "cifs/%s%s",
+					host, domainname);
+			freeaddrinfo(ai);
+			if (rc < 0 || (size_t)rc >= sizeof(princ)) {
+				syslog(LOG_ERR, "Problem setting hostname in string: %ld", rc);
+				rc = -EINVAL;
+				break;
+			}
+
+			rc = handle_krb5_mech(oid, princ, &secblob, &sess_key, ccname);
+			if (!rc)
+				break;
+		}
+
 		if (!try_dns || !(have & DKD_HAVE_IP))
 			break;
 
@@ -913,7 +978,6 @@ retry_new_hostname:
 		if (rc)
 			break;
 
-		SAFE_FREE(princ);
 		try_dns = 0;
 		host = hostbuf;
 		goto retry_new_hostname;
@@ -923,8 +987,6 @@ retry_new_hostname:
 		break;
 	}
 
-	SAFE_FREE(princ);
-
 	if (rc)
 		goto out;
 
